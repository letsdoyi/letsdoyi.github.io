---
title: "컵 돌리기 게임"
date: 2019-05-08 00:51:07
categories: Algorithm
---

세 개의 뒤집힌 컵 중 한 개의 컵 안에 열쇠가 있습니다. 당신이 열쇠를 찾기 위해 컵을 들어올리려는 순간, Drogon이 빠르게 컵의 위치를 뒤섞기 시작합니다. 컵의 교환이 끝났을 때, 열쇠가 들어있는 컵을 찾아야 합니다. 컵의 위치는 인덱스로 표현됩니다. (0부터 시작) 키가 들어있는 컵의 인덱스와 교환된 컵의 인덱스를 나타내는 배열(swaps)을 입력으로 받습니다.

<!-- more -->

\* 예를들어, 열쇠가 들어있는 컵의 처음 위치가 `0`이고 컵이 교환되는 순서가 다음과 같다면 [(0, 1), (1, 2), (1, 0)]

- 첫 교환때 열쇠가 있는 컵은 0 에서 1로 이동하게 됩니다.
- 두번째 교환때 열쇠가 있는 컵은 1 에서 2로 이동하게 됩니다.
- 마지막 교환때 1에 있는 컵이 0으로 가지만, 열쇠가 있는 컵에는 영향을 미치지 않습니다.
- 따라서 열쇠가 있는 컵의 위치는 2가 됩니다.

\* swaps = [[0, 1], [1, 2], [1, 0]]

\* firstPosition = 0

\* findKey(firstPosition, swaps) == 2

\* 컵의 갯수는 최소한 두 개 이상입니다.

```js
function findKey(start, swaps) {}
```

## 문제 이해

_각 과정 중 시간이 가장 많이 든 과정이다. 배열의 합으로 이루어진 swaps 배열의 의미를 이해하는 부분이 생소하였다._

컵을 돌리기 게임을 상상했다. ![cupSwapGame](https://img.auctiva.com/imgdata/2/0/3/3/6/7/8/webimg/1027498237_o.gif)

swaps 배열 안의 각각의 요소들은 한번의 교환을 의미한다. 예를 들어 요소 0번인 [0, 1]은 0번의 컵을 1번의 컵과 교환하는 것을 의미한다. start는 키가 들어있는 처음 컵의 위치를 나타낸다.

## 해결 방법

- 배열에서 index() 메서드를 이용해 가장 먼저 등장하는 키가 들어있는 컵의 위치를 찾는다.
- 그 요소 배열의 컵의 위치를 바꿔준다. 두번째에 있을 경우 첫번째로, 첫번째에 있을 경우 두번째로 바꿔준다.
- 배열의 길이가 끝날때 까지 계속 키가 들어있는 컵의 위치를 찾고 위치를 바꾸는 작업을 계속한다.

## 코드 구현

```js
function findKey(start, swaps) {
  if (swaps.length === 0) {
    return start;
  } else {
    for (var i = 0; i < swaps.length; i++) {
      if (swaps[i].indexOf(start) != -1) {
        var find = swaps[i].indexOf(start); //find는 열쇠 위치의 인덱스
        if (find === 0) {
          find += 1;
        } else {
          find -= 1;
        } //이제 find는 바뀐 위치의 인덱스
        start = swaps[i][find]; //바뀐 위치의 열쇠가 들어간 컵 숫자
      }
    }
    return start;
  }
}
```

## 결과 분석

```js
"빈 swaps가 주어지면 처음 위치를 반환해야 한다.";
findKey(3, []); // 3
("컵이 2개일 때, 열쇠가 있는 컵의 위치를 반환해야 한다.");
findKey(1, [[0, 1]]); // 0
("컵이 3개일 때, 열쇠가 있는 컵의 위치를 반환해야 한다.");
findKey(0, [
  [0, 1],
  [2, 1],
  [0, 1]
]); // 2
("컵이 10개일 때, 열쇠가 있는 컵의 위치를 반환해야 한다.");
findKey(4, [
  [0, 9],
  [9, 3],
  [3, 7],
  [7, 8],
  [8, 2],
  [4, 5]
]); // 5
```

컵의 개수에 상관없이 원하는 컵의 위치를 찾아낸다.
